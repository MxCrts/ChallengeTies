import React, { createContext, useContext, useState, ReactNode } from "react";
import {
  doc,
  updateDoc,
  arrayUnion,
  getDoc,
  increment,
} from "firebase/firestore";
import { db, auth } from "../constants/firebase-config";
import { checkForAchievements } from "../helpers/trophiesHelpers";
import { achievementsList } from "../helpers/achievementsConfig";

interface ProfileUpdateContextProps {
  triggerProfileUpdate: () => Promise<void>;
  profileUpdated: boolean;
}

const ProfileUpdateContext = createContext<
  ProfileUpdateContextProps | undefined
>(undefined);

export const ProfileUpdateProvider: React.FC<{ children: ReactNode }> = ({
  children,
}) => {
  const [profileUpdated, setProfileUpdated] = useState(false);

  const triggerProfileUpdate = async () => {
    const userId = auth.currentUser?.uid;
    if (!userId) return;

    const userRef = doc(db, "users", userId);
    const userDoc = await getDoc(userRef);
    if (!userDoc.exists()) return;

    const userData = userDoc.data();
    console.log("üì¢ Firestore Data (Avant update) :", userData);
    console.log("üì¢ Succ√®s d√©j√† obtenus :", userData.achievements);
    console.log("üì¢ Succ√®s en attente :", userData.newAchievements);

    // R√©cup√®re les nouveaux succ√®s via la v√©rification
    let newAchievements: string[] = await checkForAchievements(userId);

    // Forcer "first_connection" si non pr√©sent
    if (
      !userData.achievements?.includes("first_connection") &&
      !userData.newAchievements?.includes("first_connection")
    ) {
      newAchievements.push("first_connection");
    }

    // Forcer "profile_completed" si le profil semble complet
    // On s'assure ici que les champs attendus sont pr√©sents et, pour interests, qu'il s'agit d'un tableau non vide
    if (
      userData.bio &&
      userData.location &&
      userData.profileImage &&
      Array.isArray(userData.interests) &&
      userData.interests.length > 0 &&
      !userData.achievements?.includes("profile_completed") &&
      !userData.newAchievements?.includes("profile_completed")
    ) {
      newAchievements.push("profile_completed");
    }

    if (newAchievements.length === 0) return;

    // Si "first_connection" n'est pas d√©j√† dans newAchievements, l'ajouter manuellement (optionnel)
    if (!userData.newAchievements?.includes("first_connection")) {
      await updateDoc(userRef, {
        newAchievements: arrayUnion("first_connection"),
      });
      console.log("üî• Ajout manuel de 'first_connection' √† Firestore !");
    }

    // Calcul du nombre total de troph√©es gagn√©s
    let totalTrophies = newAchievements.reduce((acc, achievementKey) => {
      Object.entries(achievementsList).forEach(([key, value]) => {
        if (typeof value === "object" && "name" in value && "points" in value) {
          if (achievementKey === key) {
            acc += value.points;
          }
        } else {
          Object.entries(value).forEach(([threshold, achievementData]) => {
            if (`${key}-${threshold}` === achievementKey) {
              acc += (achievementData as { name: string; points: number })
                .points;
            }
          });
        }
      });
      return acc;
    }, 0);

    // Met √† jour Firestore avec les nouveaux succ√®s et incr√©mente les troph√©es
    await updateDoc(userRef, {
      newAchievements: arrayUnion(...newAchievements),
      achievements: arrayUnion(...newAchievements),
      trophies: increment(totalTrophies),
    });

    console.log(
      `‚úÖ Succ√®s ajout√©s: ${newAchievements.join(
        ", "
      )} | Troph√©es gagn√©s: ${totalTrophies}`
    );
    setProfileUpdated((prev) => !prev);
  };

  return (
    <ProfileUpdateContext.Provider
      value={{ triggerProfileUpdate, profileUpdated }}
    >
      {children}
    </ProfileUpdateContext.Provider>
  );
};

export const useProfileUpdate = () => {
  const context = useContext(ProfileUpdateContext);
  if (!context) {
    throw new Error(
      "‚ùå useProfileUpdate doit √™tre utilis√© √† l'int√©rieur de ProfileUpdateProvider."
    );
  }
  return context;
};
